# Generate the decision and localisation files from the core buildings files
# Note that this ignores all mods and operates directly on the base files.
import json
import os.path
import re
import subprocess
import sys
from collections import defaultdict
# Is there a way to ask Steam where the game's installed? No biggie, it's just for
# updating after a big game change.
GAME_DIR = os.path.expanduser("~/.steam/steam/steamapps/common/Europa Universalis IV")
# See the EU4Parse repository, which has a yacc-based parser. Use what already exists, eh?
PARSER = os.path.expanduser("~/EU4Parse/savefile")
BUILDINGS_DIR = GAME_DIR + "/common/buildings"
L10N_DIR = GAME_DIR + "/localisation"

# Hackily parse the localisation files and try to find the names.
# TODO: Don't do this at all; reference the keys in question instead of copying the values.
names = { }
for fn in sorted(os.listdir(L10N_DIR)):
	if not fn.endswith("english.yml"): continue
	with open(L10N_DIR + "/" + fn, "rt") as f:
		next(f) # Skip the heading
		for line in f:
			if m := re.match(r"^ building_(.*?):[0-9]+ \"(.*?)\"$", line):
				names[m.group(1)] = m.group(2)

def L10N(id): return names.get(id, id)

# First figure out the full list of buildings that obsolete other buildings.
# If anything fails at this stage (eg parsing the files), don't destroy the script file.
obsoletes = { }
prices = defaultdict(int)
for fn in sorted(os.listdir(BUILDINGS_DIR)):
	p = subprocess.run([PARSER, BUILDINGS_DIR + "/" + fn], capture_output=True)
	data = json.loads(p.stdout)
	for id, info in data.items():
		if "make_obsolete" not in info: continue
		obsoletes[id] = [*obsoletes.get(info["make_obsolete"], ()), info["make_obsolete"]]
		for old in obsoletes[id]:
			prices[old, id] = int(info["cost"]) - int(data[old]["cost"])
		print("%20s %r" % (L10N(id), obsoletes[id]))

DECISION = """	upgrade_to_$new$ = {
		color = { 102 51 153 } # rebeccapurple
		potential = {
			# This SHOULD be balanced, but for now, make it player-only
			ai = no
			any_owned_province = {
				can_build = $new$
				$has$
			}
		}
		allow = {
			any_owned_province = {
				can_build = $new$
				$has$
			}
			treasury = $price$ # Note that this ignores cost modifications. You have to have the base price on hand.
		}
		effect = {
			every_owned_province = {
				limit = {
					can_build = $new$
					$has$
					owner = { treasury = $price$ } # Once you no longer have the base price, stop building.
				}
				add_building_construction = { building = $new$ }
				save_event_target_as = last_built_province
			}
			# If it took you into the red...
			if = {
				limit = { NOT = { treasury = 0 } }
				# ... cancel the last one built.
				# This isn't perfect - I would much rather the number in both "allow" and "limit" were
				# affected by actual cost modifications - but at least you won't go into debt for this.
				event_target:last_built_province = { cancel_construction = yes }
			}
		}
		ai_will_do = {
			factor = 0
		}
	}
"""

root = os.path.dirname(sys.argv[0]) or "."
with open("decisions/00_bulk_upgrades.txt", "wt") as f, open("localisation/bulkupgrades_l_english.yml", "wt") as loc:
	print("# AUTOGENERATED BY build.py - DO NOT EDIT", file=f)
	print("country_decisions = {", file=f)
	print("\ufeffl_english:", file=loc)
	for new, olds in obsoletes.items():
		if len(olds) > 1:
			has = "OR = { " + " ".join("has_building = " + id for id in olds) + " }"
		else:
			has = "has_building = " + new
		# TODO: Change the hover text to be descriptive rather than exhaustive
		print(DECISION
			.replace("$new$", new)
			.replace("$has$", has)
			# TODO: Check treasury based on *each* possible upgrade, not a single price for all
			.replace("$price$", str(prices[olds[0], new]))
		, file=f)
		print(' upgrade_to_%s_title:0 "Building upgrade: %s"' % (new, L10N(new)), file=loc)
		print(' upgrade_to_%s_desc:0 "Start upgrading as many as you can afford to %s"' % (new, L10N(new)), file=loc)
	print("}", file=f)
